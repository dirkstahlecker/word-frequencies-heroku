{"ast":null,"code":"var _jsxFileName = \"/Users/dirkstahlecker/programming/word-frequencies-heroku/src/stats/NamesDB.tsx\";\nimport { Markup } from \"./Markup\";\nimport * as React from \"react\"; // export class NamesDB\n// {\n//   private namesDict: Set<WordInfo> = new Set();\n// }\n\nexport class WordInfo {\n  //set can't identify duplicate dates\n  constructor(word, count, date) {\n    this._word = void 0;\n    this._count = void 0;\n    this._dates = [];\n    this._word = word;\n    this._count = count;\n\n    if (date !== undefined) {\n      this.addDate(date);\n    }\n  }\n\n  get word() {\n    return this._word;\n  }\n\n  set word(value) {\n    this._word = value;\n  }\n\n  get count() {\n    return this._count;\n  }\n\n  set count(value) {\n    this._count = value;\n  }\n\n  get dates() {\n    return this._dates;\n  } //TODO: the set isn't keeping the dates unique\n\n\n  addDate(newDate) {\n    //TODO: very inefficient\n    this._dates.forEach(date => {\n      if (date.getTime() === newDate.getTime()) {\n        return; //already here, nothing to do\n      }\n    });\n\n    this._dates.push(newDate);\n  }\n\n  clearDates() {\n    this._dates = [];\n  }\n\n  getSortedDates() {\n    const sortedArray = Array.from(this._dates).sort((a, b) => {\n      return a.getTime() - b.getTime();\n    });\n    return sortedArray;\n  }\n\n  getFirstDate() {\n    return this.getSortedDates()[0];\n  }\n\n  getLastDate() {\n    const sortedDates = this.getSortedDates();\n    return sortedDates[sortedDates.length - 1];\n  }\n\n  makeHtmlElememt() {\n    console.error(\"Not implemented\");\n    return null;\n  }\n\n} //word is firstName_lastName\n\nexport class NameInfo extends WordInfo {\n  constructor(markup, count, date) {\n    super(markup.getKey(), count, date);\n    this.displayNames = new Set();\n    this._markup = void 0;\n    this._markup = markup;\n    this.displayNames.add(markup.displayName);\n  }\n\n  set word(value) {\n    if (!Markup.isMarkup(value)) {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n\n    this._word = Markup.create(value).getKey();\n  }\n\n  get word() {\n    return this.markup.displayName; //TODO:\n  }\n\n  get markup() {\n    return this._markup;\n  }\n\n  addDisplayName(displayName) {\n    this.displayNames.add(displayName);\n  } //display name doesn't matter - only first and last name pair is unique\n\n\n  static equals(a, b) {\n    return a.markup.firstName === b.markup.firstName && a.markup.lastName === b.markup.lastName;\n  } //key is used as the map key to group unique first/last name pairs regardless\n  //of display names\n\n\n  getKey() {\n    return this.markup.getKey();\n  }\n\n  makeTooltip() {\n    const markup = this.markup;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149,\n        columnNumber: 12\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 150,\n        columnNumber: 7\n      }\n    }, \"Display Names: \", Array.from(this.displayNames).map(displayName => {\n      return /*#__PURE__*/React.createElement(\"span\", {\n        key: this.getKey() + displayName,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 154,\n          columnNumber: 20\n        }\n      }, displayName, \",\\xA0\");\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 7\n      }\n    }, \"Unique Days:\"), /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 7\n      }\n    }, \"Average usages per day:\"), /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 166,\n        columnNumber: 7\n      }\n    }));\n  }\n\n  makeHtmlElememt() {\n    const markup = this.markup;\n\n    if (markup == null || markup.firstName == null || markup.lastName == null || markup.displayName == null) {\n      return null;\n    } //TODO: show multiple display names\n\n\n    return /*#__PURE__*/React.createElement(\"span\", {\n      className: \"rendered-markup-display-name\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 181,\n        columnNumber: 12\n      }\n    }, markup.firstName + \" \" + markup.lastName, /*#__PURE__*/React.createElement(\"span\", {\n      className: \"tooltip\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 7\n      }\n    }, this.makeTooltip()));\n  }\n\n}","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/src/stats/NamesDB.tsx"],"names":["Markup","React","WordInfo","constructor","word","count","date","_word","_count","_dates","undefined","addDate","value","dates","newDate","forEach","getTime","push","clearDates","getSortedDates","sortedArray","Array","from","sort","a","b","getFirstDate","getLastDate","sortedDates","length","makeHtmlElememt","console","error","NameInfo","markup","getKey","displayNames","Set","_markup","add","displayName","isMarkup","Error","create","addDisplayName","equals","firstName","lastName","makeTooltip","map"],"mappings":"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","sourcesContent":["import {Markup} from \"./Markup\";\nimport * as React from \"react\";\n\n// export class NamesDB\n// {\n//   private namesDict: Set<WordInfo> = new Set();\n// }\n\nexport class WordInfo\n{\n  protected _word: string;\n  protected _count: number;\n  protected _dates: Date[] = []; //set can't identify duplicate dates\n\n  constructor(word: string, count: number, date?: Date)\n  {\n    this._word = word;\n    this._count = count;\n    if (date !== undefined)\n    {\n      this.addDate(date);\n    }\n  }\n\n  public get word(): string\n  {\n    return this._word;\n  }\n\n  public set word(value: string)\n  {\n    this._word = value;\n  }\n\n  public get count(): number\n  {\n    return this._count;\n  }\n\n  public set count(value: number)\n  {\n    this._count = value;\n  }\n\n  public get dates(): Date[]\n  {\n    return this._dates;\n  }\n\n//TODO: the set isn't keeping the dates unique\n  public addDate(newDate: Date): void\n  {\n    //TODO: very inefficient\n    this._dates.forEach((date: Date) => {\n      if (date.getTime() === newDate.getTime())\n      {\n        return; //already here, nothing to do\n      }\n    });\n    this._dates.push(newDate);\n  }\n\n  public clearDates(): void\n  {\n    this._dates = [];\n  }\n\n  private getSortedDates(): Date[]\n  {\n    const sortedArray = Array.from(this._dates).sort((a: Date, b: Date) => {\n      return a.getTime() - b.getTime();\n    });\n    return sortedArray;\n  }\n\n  public getFirstDate(): Date\n  {\n    return this.getSortedDates()[0];\n  }\n\n  public getLastDate(): Date\n  {\n    const sortedDates: Date[] = this.getSortedDates();\n    return sortedDates[sortedDates.length - 1];\n  }\n\n  public makeHtmlElememt(): JSX.Element | null\n  {\n    console.error(\"Not implemented\");\n    return null;\n  }\n}\n\n//word is firstName_lastName\nexport class NameInfo extends WordInfo\n{\n  constructor(markup: Markup, count: number, date?: Date)\n  {\n    super(markup.getKey(), count, date);\n    this._markup = markup;\n    this.displayNames.add(markup.displayName);\n  }\n\n  public displayNames: Set<String> = new Set();\n  private _markup: Markup;\n\n  public set word(value: string)\n  {\n    if (!Markup.isMarkup(value))\n    {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n    this._word = Markup.create(value).getKey();\n  }\n\n  public get word(): string\n  {\n    return this.markup.displayName; //TODO:\n  }\n\n  public get markup(): Markup\n  {\n    return this._markup;\n  }\n\n  public addDisplayName(displayName: string): void\n  {\n    this.displayNames.add(displayName);\n  }\n\n  //display name doesn't matter - only first and last name pair is unique\n  public static equals(a: NameInfo, b: NameInfo): boolean\n  {\n    return a.markup.firstName === b.markup.firstName\n        && a.markup.lastName === b.markup.lastName;\n  }\n\n  //key is used as the map key to group unique first/last name pairs regardless\n  //of display names\n  public getKey(): string\n  {\n    return this.markup.getKey();\n  }\n\n  private makeTooltip(): JSX.Element\n  {\n    const markup: Markup = this.markup;\n\n    return <div>\n      <div>\n        {\"Display Names: \"}\n        {\n          Array.from(this.displayNames).map((displayName: String) => {\n            return <span key={this.getKey() + displayName}>\n              {displayName},&nbsp;\n            </span>;\n          })\n        }\n      </div>\n      <div>\n        Unique Days:\n      </div>\n      <div>\n        Average usages per day:\n      </div>\n      <div>\n\n      </div>\n    </div>;\n  }\n\n  public makeHtmlElememt(): JSX.Element | null\n  {\n    const markup: Markup = this.markup;\n    if (markup == null || markup.firstName == null || markup.lastName == null || markup.displayName == null)\n    {\n      return null;\n    }\n\n    //TODO: show multiple display names\n    return <span className=\"rendered-markup-display-name\">\n      {markup.firstName + \" \" + markup.lastName}\n      <span className=\"tooltip\">\n        {this.makeTooltip()}\n      </span>\n    </span>;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}