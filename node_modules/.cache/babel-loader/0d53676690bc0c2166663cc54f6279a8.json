{"ast":null,"code":"'use strict';\n\nvar extend = require('xtend/mutable');\n\nmodule.exports = PostgresInterval;\n\nfunction PostgresInterval(raw) {\n  if (!(this instanceof PostgresInterval)) {\n    return new PostgresInterval(raw);\n  }\n\n  extend(this, parse(raw));\n}\n\nvar properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];\n\nPostgresInterval.prototype.toPostgres = function () {\n  var filtered = properties.filter(this.hasOwnProperty, this); // In addition to `properties`, we need to account for fractions of seconds.\n\n  if (this.milliseconds && filtered.indexOf('seconds') < 0) {\n    filtered.push('seconds');\n  }\n\n  if (filtered.length === 0) return '0';\n  return filtered.map(function (property) {\n    var value = this[property] || 0; // Account for fractional part of seconds,\n    // remove trailing zeroes.\n\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/\\.?0+$/, '');\n    }\n\n    return value + ' ' + property;\n  }, this).join(' ');\n};\n\nvar propertiesISOEquivalent = {\n  years: 'Y',\n  months: 'M',\n  days: 'D',\n  hours: 'H',\n  minutes: 'M',\n  seconds: 'S'\n};\nvar dateProperties = ['years', 'months', 'days'];\nvar timeProperties = ['hours', 'minutes', 'seconds']; // according to ISO 8601\n\nPostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {\n  var datePart = dateProperties.map(buildProperty, this).join('');\n  var timePart = timeProperties.map(buildProperty, this).join('');\n  return 'P' + datePart + 'T' + timePart;\n\n  function buildProperty(property) {\n    var value = this[property] || 0; // Account for fractional part of seconds,\n    // remove trailing zeroes.\n\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '');\n    }\n\n    return value + propertiesISOEquivalent[property];\n  }\n};\n\nvar NUMBER = '([+-]?\\\\d+)';\nvar YEAR = NUMBER + '\\\\s+years?';\nvar MONTH = NUMBER + '\\\\s+mons?';\nvar DAY = NUMBER + '\\\\s+days?';\nvar TIME = '([+-])?([\\\\d]*):(\\\\d\\\\d):(\\\\d\\\\d)\\\\.?(\\\\d{1,6})?';\nvar INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {\n  return '(' + regexString + ')?';\n}).join('\\\\s*')); // Positions of values in regex match\n\nvar positions = {\n  years: 2,\n  months: 4,\n  days: 6,\n  hours: 9,\n  minutes: 10,\n  seconds: 11,\n  milliseconds: 12\n}; // We can use negative time\n\nvar negatives = ['hours', 'minutes', 'seconds', 'milliseconds'];\n\nfunction parseMilliseconds(fraction) {\n  // add omitted zeroes\n  var microseconds = fraction + '000000'.slice(fraction.length);\n  return parseInt(microseconds, 10) / 1000;\n}\n\nfunction parse(interval) {\n  if (!interval) return {};\n  var matches = INTERVAL.exec(interval);\n  var isNegative = matches[8] === '-';\n  return Object.keys(positions).reduce(function (parsed, property) {\n    var position = positions[property];\n    var value = matches[position]; // no empty string\n\n    if (!value) return parsed; // milliseconds are actually microseconds (up to 6 digits)\n    // with omitted trailing zeroes.\n\n    value = property === 'milliseconds' ? parseMilliseconds(value) : parseInt(value, 10); // no zeros\n\n    if (!value) return parsed;\n\n    if (isNegative && ~negatives.indexOf(property)) {\n      value *= -1;\n    }\n\n    parsed[property] = value;\n    return parsed;\n  }, {});\n}","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/postgres-interval/index.js"],"names":["extend","require","module","exports","PostgresInterval","raw","parse","properties","prototype","toPostgres","filtered","filter","hasOwnProperty","milliseconds","indexOf","push","length","map","property","value","toFixed","replace","join","propertiesISOEquivalent","years","months","days","hours","minutes","seconds","dateProperties","timeProperties","toISOString","toISO","datePart","buildProperty","timePart","NUMBER","YEAR","MONTH","DAY","TIME","INTERVAL","RegExp","regexString","positions","negatives","parseMilliseconds","fraction","microseconds","slice","parseInt","interval","matches","exec","isNegative","Object","keys","reduce","parsed","position"],"mappings":"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","sourcesContent":["'use strict'\n\nvar extend = require('xtend/mutable')\n\nmodule.exports = PostgresInterval\n\nfunction PostgresInterval (raw) {\n  if (!(this instanceof PostgresInterval)) {\n    return new PostgresInterval(raw)\n  }\n  extend(this, parse(raw))\n}\nvar properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']\nPostgresInterval.prototype.toPostgres = function () {\n  var filtered = properties.filter(this.hasOwnProperty, this)\n\n  // In addition to `properties`, we need to account for fractions of seconds.\n  if (this.milliseconds && filtered.indexOf('seconds') < 0) {\n    filtered.push('seconds')\n  }\n\n  if (filtered.length === 0) return '0'\n  return filtered\n    .map(function (property) {\n      var value = this[property] || 0\n\n      // Account for fractional part of seconds,\n      // remove trailing zeroes.\n      if (property === 'seconds' && this.milliseconds) {\n        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\\.?0+$/, '')\n      }\n\n      return value + ' ' + property\n    }, this)\n    .join(' ')\n}\n\nvar propertiesISOEquivalent = {\n  years: 'Y',\n  months: 'M',\n  days: 'D',\n  hours: 'H',\n  minutes: 'M',\n  seconds: 'S'\n}\nvar dateProperties = ['years', 'months', 'days']\nvar timeProperties = ['hours', 'minutes', 'seconds']\n// according to ISO 8601\nPostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {\n  var datePart = dateProperties\n    .map(buildProperty, this)\n    .join('')\n\n  var timePart = timeProperties\n    .map(buildProperty, this)\n    .join('')\n\n  return 'P' + datePart + 'T' + timePart\n\n  function buildProperty (property) {\n    var value = this[property] || 0\n\n    // Account for fractional part of seconds,\n    // remove trailing zeroes.\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '')\n    }\n\n    return value + propertiesISOEquivalent[property]\n  }\n}\n\nvar NUMBER = '([+-]?\\\\d+)'\nvar YEAR = NUMBER + '\\\\s+years?'\nvar MONTH = NUMBER + '\\\\s+mons?'\nvar DAY = NUMBER + '\\\\s+days?'\nvar TIME = '([+-])?([\\\\d]*):(\\\\d\\\\d):(\\\\d\\\\d)\\\\.?(\\\\d{1,6})?'\nvar INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {\n  return '(' + regexString + ')?'\n})\n  .join('\\\\s*'))\n\n// Positions of values in regex match\nvar positions = {\n  years: 2,\n  months: 4,\n  days: 6,\n  hours: 9,\n  minutes: 10,\n  seconds: 11,\n  milliseconds: 12\n}\n// We can use negative time\nvar negatives = ['hours', 'minutes', 'seconds', 'milliseconds']\n\nfunction parseMilliseconds (fraction) {\n  // add omitted zeroes\n  var microseconds = fraction + '000000'.slice(fraction.length)\n  return parseInt(microseconds, 10) / 1000\n}\n\nfunction parse (interval) {\n  if (!interval) return {}\n  var matches = INTERVAL.exec(interval)\n  var isNegative = matches[8] === '-'\n  return Object.keys(positions)\n    .reduce(function (parsed, property) {\n      var position = positions[property]\n      var value = matches[position]\n      // no empty string\n      if (!value) return parsed\n      // milliseconds are actually microseconds (up to 6 digits)\n      // with omitted trailing zeroes.\n      value = property === 'milliseconds'\n        ? parseMilliseconds(value)\n        : parseInt(value, 10)\n      // no zeros\n      if (!value) return parsed\n      if (isNegative && ~negatives.indexOf(property)) {\n        value *= -1\n      }\n      parsed[property] = value\n      return parsed\n    }, {})\n}\n"]},"metadata":{},"sourceType":"script"}