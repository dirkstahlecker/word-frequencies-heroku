{"ast":null,"code":"//binary data writer tuned for creating\n//postgres message packets as effeciently as possible by reusing the\n//same buffer to avoid memcpy and limit memory allocations\nvar Writer = module.exports = function (size) {\n  this.size = size || 1024;\n  this.buffer = Buffer.alloc(this.size + 5);\n  this.offset = 5;\n  this.headerPosition = 0;\n}; //resizes internal buffer if not enough size left\n\n\nWriter.prototype._ensure = function (size) {\n  var remaining = this.buffer.length - this.offset;\n\n  if (remaining < size) {\n    var oldBuffer = this.buffer; // exponential growth factor of around ~ 1.5\n    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n\n    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;\n    this.buffer = Buffer.alloc(newSize);\n    oldBuffer.copy(this.buffer);\n  }\n};\n\nWriter.prototype.addInt32 = function (num) {\n  this._ensure(4);\n\n  this.buffer[this.offset++] = num >>> 24 & 0xFF;\n  this.buffer[this.offset++] = num >>> 16 & 0xFF;\n  this.buffer[this.offset++] = num >>> 8 & 0xFF;\n  this.buffer[this.offset++] = num >>> 0 & 0xFF;\n  return this;\n};\n\nWriter.prototype.addInt16 = function (num) {\n  this._ensure(2);\n\n  this.buffer[this.offset++] = num >>> 8 & 0xFF;\n  this.buffer[this.offset++] = num >>> 0 & 0xFF;\n  return this;\n}; //for versions of node requiring 'length' as 3rd argument to buffer.write\n\n\nvar writeString = function (buffer, string, offset, len) {\n  buffer.write(string, offset, len);\n}; //overwrite function for older versions of node\n\n\nif (Buffer.prototype.write.length === 3) {\n  writeString = function (buffer, string, offset, len) {\n    buffer.write(string, offset);\n  };\n}\n\nWriter.prototype.addCString = function (string) {\n  //just write a 0 for empty or null strings\n  if (!string) {\n    this._ensure(1);\n  } else {\n    var len = Buffer.byteLength(string);\n\n    this._ensure(len + 1); //+1 for null terminator\n\n\n    writeString(this.buffer, string, this.offset, len);\n    this.offset += len;\n  }\n\n  this.buffer[this.offset++] = 0; // null terminator\n\n  return this;\n};\n\nWriter.prototype.addChar = function (c) {\n  this._ensure(1);\n\n  writeString(this.buffer, c, this.offset, 1);\n  this.offset++;\n  return this;\n};\n\nWriter.prototype.addString = function (string) {\n  string = string || \"\";\n  var len = Buffer.byteLength(string);\n\n  this._ensure(len);\n\n  this.buffer.write(string, this.offset);\n  this.offset += len;\n  return this;\n};\n\nWriter.prototype.getByteLength = function () {\n  return this.offset - 5;\n};\n\nWriter.prototype.add = function (otherBuffer) {\n  this._ensure(otherBuffer.length);\n\n  otherBuffer.copy(this.buffer, this.offset);\n  this.offset += otherBuffer.length;\n  return this;\n};\n\nWriter.prototype.clear = function () {\n  this.offset = 5;\n  this.headerPosition = 0;\n  this.lastEnd = 0;\n}; //appends a header block to all the written data since the last\n//subsequent header or to the beginning if there is only one data block\n\n\nWriter.prototype.addHeader = function (code, last) {\n  var origOffset = this.offset;\n  this.offset = this.headerPosition;\n  this.buffer[this.offset++] = code; //length is everything in this packet minus the code\n\n  this.addInt32(origOffset - (this.headerPosition + 1)); //set next header position\n\n  this.headerPosition = origOffset; //make space for next header\n\n  this.offset = origOffset;\n\n  if (!last) {\n    this._ensure(5);\n\n    this.offset += 5;\n  }\n};\n\nWriter.prototype.join = function (code) {\n  if (code) {\n    this.addHeader(code, true);\n  }\n\n  return this.buffer.slice(code ? 0 : 5, this.offset);\n};\n\nWriter.prototype.flush = function (code) {\n  var result = this.join(code);\n  this.clear();\n  return result;\n};","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/buffer-writer/index.js"],"names":["Writer","module","exports","size","buffer","Buffer","alloc","offset","headerPosition","prototype","_ensure","remaining","length","oldBuffer","newSize","copy","addInt32","num","addInt16","writeString","string","len","write","addCString","byteLength","addChar","c","addString","getByteLength","add","otherBuffer","clear","lastEnd","addHeader","code","last","origOffset","join","slice","flush","result"],"mappings":"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","sourcesContent":["//binary data writer tuned for creating\n//postgres message packets as effeciently as possible by reusing the\n//same buffer to avoid memcpy and limit memory allocations\nvar Writer = module.exports = function (size) {\n  this.size = size || 1024;\n  this.buffer = Buffer.alloc(this.size + 5);\n  this.offset = 5;\n  this.headerPosition = 0;\n};\n\n//resizes internal buffer if not enough size left\nWriter.prototype._ensure = function (size) {\n  var remaining = this.buffer.length - this.offset;\n  if (remaining < size) {\n    var oldBuffer = this.buffer;\n    // exponential growth factor of around ~ 1.5\n    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;\n    this.buffer = Buffer.alloc(newSize);\n    oldBuffer.copy(this.buffer);\n  }\n};\n\nWriter.prototype.addInt32 = function (num) {\n  this._ensure(4);\n  this.buffer[this.offset++] = (num >>> 24 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 16 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 8 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 0 & 0xFF);\n  return this;\n};\n\nWriter.prototype.addInt16 = function (num) {\n  this._ensure(2);\n  this.buffer[this.offset++] = (num >>> 8 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 0 & 0xFF);\n  return this;\n};\n\n//for versions of node requiring 'length' as 3rd argument to buffer.write\nvar writeString = function (buffer, string, offset, len) {\n  buffer.write(string, offset, len);\n};\n\n//overwrite function for older versions of node\nif (Buffer.prototype.write.length === 3) {\n  writeString = function (buffer, string, offset, len) {\n    buffer.write(string, offset);\n  };\n}\n\nWriter.prototype.addCString = function (string) {\n  //just write a 0 for empty or null strings\n  if (!string) {\n    this._ensure(1);\n  } else {\n    var len = Buffer.byteLength(string);\n    this._ensure(len + 1); //+1 for null terminator\n    writeString(this.buffer, string, this.offset, len);\n    this.offset += len;\n  }\n\n  this.buffer[this.offset++] = 0; // null terminator\n  return this;\n};\n\nWriter.prototype.addChar = function (c) {\n  this._ensure(1);\n  writeString(this.buffer, c, this.offset, 1);\n  this.offset++;\n  return this;\n};\n\nWriter.prototype.addString = function (string) {\n  string = string || \"\";\n  var len = Buffer.byteLength(string);\n  this._ensure(len);\n  this.buffer.write(string, this.offset);\n  this.offset += len;\n  return this;\n};\n\nWriter.prototype.getByteLength = function () {\n  return this.offset - 5;\n};\n\nWriter.prototype.add = function (otherBuffer) {\n  this._ensure(otherBuffer.length);\n  otherBuffer.copy(this.buffer, this.offset);\n  this.offset += otherBuffer.length;\n  return this;\n};\n\nWriter.prototype.clear = function () {\n  this.offset = 5;\n  this.headerPosition = 0;\n  this.lastEnd = 0;\n};\n\n//appends a header block to all the written data since the last\n//subsequent header or to the beginning if there is only one data block\nWriter.prototype.addHeader = function (code, last) {\n  var origOffset = this.offset;\n  this.offset = this.headerPosition;\n  this.buffer[this.offset++] = code;\n  //length is everything in this packet minus the code\n  this.addInt32(origOffset - (this.headerPosition + 1));\n  //set next header position\n  this.headerPosition = origOffset;\n  //make space for next header\n  this.offset = origOffset;\n  if (!last) {\n    this._ensure(5);\n    this.offset += 5;\n  }\n};\n\nWriter.prototype.join = function (code) {\n  if (code) {\n    this.addHeader(code, true);\n  }\n  return this.buffer.slice(code ? 0 : 5, this.offset);\n};\n\nWriter.prototype.flush = function (code) {\n  var result = this.join(code);\n  this.clear();\n  return result;\n};\n"]},"metadata":{},"sourceType":"script"}