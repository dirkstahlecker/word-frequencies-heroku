{"ast":null,"code":"import _initializerDefineProperty from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class,\n    _descriptor,\n    _descriptor2,\n    _descriptor3,\n    _descriptor4,\n    _temp,\n    _class3,\n    _jsxFileName = \"/Users/dirkstahlecker/programming/word-frequencies-heroku/src/stats/Stats.tsx\";\n\nimport * as React from \"react\";\nimport { observable, action } from \"mobx\";\nimport { observer } from \"mobx-react\";\nimport { JournalReaderMachine } from \"../JournalReader\";\nimport { NameInfo } from \"./NamesDB\";\nimport { Markup } from \"./Markup\";\nimport { NameCounts } from \"./NameCounts\";\nimport { Utils } from \"../Utils\";\nexport let StatsMachine = (_class = (_temp = class StatsMachine {\n  // private namesDB: NamesDB = new NamesDB();\n  constructor(journal) {// this.journal = journal; //TODO\n    // this.journal = \"1-1-20: Test journal [!!Colin|Colin_Poler!!] and \" +\n    //   \"[!!Phil|Phil_Seo!!].\\n\\n1-2-20: And [!!Colin|Colin_Poler!!].\";\n    // this.makeStats();\n\n    _initializerDefineProperty(this, \"journal\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"namesDict\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"dataFreshness\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"onJournalInputChange\", _descriptor4, this);\n  }\n\n  //remove null and empty pieces\n  cleansePieces(pieces) {\n    const ret = [];\n    pieces.forEach(piece => {\n      if (piece == null || pieces === undefined) {\n        return;\n      }\n\n      if (piece === \"\") {\n        return;\n      }\n\n      ret.push(piece.trim());\n    });\n    return ret;\n  }\n\n  makeNamesDict(pieces) {\n    let currentDate = null;\n    pieces.forEach(piece => {\n      if (JournalReaderMachine.isDate(piece)) {\n        currentDate = piece;\n      } else if (currentDate == null) {\n        return; //can't do anything if we haven't seen a date yet\n      } else if (Markup.isMarkup(piece)) {\n        const markup = Markup.create(piece);\n        const key = markup.getKey();\n        const nameInfo = this.namesDict.get(key);\n\n        if (nameInfo === undefined) {\n          const valueToSet = new NameInfo(markup, 1, Utils.makeDate(currentDate));\n          this.namesDict.set(key, valueToSet);\n        } else {\n          nameInfo.count = nameInfo.count + 1;\n          nameInfo.addDisplayName(markup.displayName); //TODO: what's the right way to do this?\n\n          nameInfo.addDate(Utils.makeDate(currentDate));\n          this.namesDict.set(key, nameInfo);\n        }\n      }\n    }); // this.namesDB\n\n    this.dataFreshness++;\n  }\n\n  makeStats() {\n    // const journal = document.getElementById(\"journalInputBox\").value();\n    let pieces = JournalReaderMachine.splitOnMarkupPiecesAndDates(this.journal);\n    pieces = this.cleansePieces(pieces);\n    this.makeNamesDict(pieces);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"journal\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return \"\";\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"namesDict\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return new Map();\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"dataFreshness\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"onJournalInputChange\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return e => {\n      this.journal = e.currentTarget.value;\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"makeNamesDict\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"makeNamesDict\"), _class.prototype)), _class);\nexport let Stats = observer(_class3 = class Stats extends React.Component {\n  get machine() {\n    return this.props.machine;\n  }\n\n  render() {\n    const x = this.machine.dataFreshness; //ignore\n\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 118,\n        columnNumber: 12\n      }\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      type: \"text\",\n      id: \"journalInputBox\",\n      onChange: this.machine.onJournalInputChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 119,\n        columnNumber: 7\n      }\n    }), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.machine.makeStats(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 7\n      }\n    }, \"Submit\"), /*#__PURE__*/React.createElement(NameCounts, {\n      namesDict: this.machine.namesDict,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 122,\n        columnNumber: 7\n      }\n    }));\n  }\n\n}) || _class3;","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/src/stats/Stats.tsx"],"names":["React","observable","action","observer","JournalReaderMachine","NameInfo","Markup","NameCounts","Utils","StatsMachine","constructor","journal","cleansePieces","pieces","ret","forEach","piece","undefined","push","trim","makeNamesDict","currentDate","isDate","isMarkup","markup","create","key","getKey","nameInfo","namesDict","get","valueToSet","makeDate","set","count","addDisplayName","displayName","addDate","dataFreshness","makeStats","splitOnMarkupPiecesAndDates","Map","e","currentTarget","value","Stats","Component","machine","props","render","x","onJournalInputChange"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {observable, runInAction, action} from \"mobx\";\nimport {observer} from \"mobx-react\";\nimport {JournalReaderMachine} from \"../JournalReader\";\nimport {NameInfo} from \"./NamesDB\";\nimport {Markup} from \"./Markup\";\nimport {NameCounts} from \"./NameCounts\";\nimport {Utils} from \"../Utils\";\n\nexport interface StatsProps\n{\n  machine: StatsMachine;\n}\n\nexport class StatsMachine\n{\n  @observable\n  private journal: string = \"\";\n\n  // private namesDB: NamesDB = new NamesDB();\n  @observable\n  public namesDict: Map<string, NameInfo> = new Map();\n\n  @observable\n  public dataFreshness: number = 0;\n\n  constructor(journal: string)\n  {\n    // this.journal = journal; //TODO\n    // this.journal = \"1-1-20: Test journal [!!Colin|Colin_Poler!!] and \" +\n    //   \"[!!Phil|Phil_Seo!!].\\n\\n1-2-20: And [!!Colin|Colin_Poler!!].\";\n    // this.makeStats();\n  }\n\n  @action\n  public onJournalInputChange = (e: any) => {\n    this.journal = e.currentTarget.value;\n  };\n\n  //remove null and empty pieces\n  private cleansePieces(pieces: string[]): string[]\n  {\n    const ret: string[] = []\n    pieces.forEach((piece: string) => {\n      if (piece == null || pieces === undefined)\n      {\n        return;\n      }\n      if (piece === \"\")\n      {\n        return;\n      }\n      ret.push(piece.trim());\n    });\n    return ret;\n  }\n\n  @action\n  private makeNamesDict(pieces: string[]): void\n  {\n    let currentDate: string | null = null;\n    pieces.forEach((piece: string) => {\n      if (JournalReaderMachine.isDate(piece))\n      {\n        currentDate = piece;\n      }\n      else if (currentDate == null)\n      {\n        return; //can't do anything if we haven't seen a date yet\n      }\n      else if (Markup.isMarkup(piece))\n      {\n        const markup: Markup = Markup.create(piece);\n        const key: string = markup.getKey();\n        const nameInfo: NameInfo | undefined = this.namesDict.get(key);\n\n        if (nameInfo === undefined)\n        {\n          const valueToSet: NameInfo = new NameInfo(markup, 1, Utils.makeDate(currentDate));\n          this.namesDict.set(key, valueToSet);\n        }\n        else\n        {\n          nameInfo.count = nameInfo.count + 1;\n          nameInfo.addDisplayName(markup.displayName); //TODO: what's the right way to do this?\n          nameInfo.addDate(Utils.makeDate(currentDate));\n          this.namesDict.set(key, nameInfo);\n        }\n      }\n    });\n    // this.namesDB\n\n    this.dataFreshness++;\n  }\n\n  public makeStats(): void\n  {\n    // const journal = document.getElementById(\"journalInputBox\").value();\n\n    let pieces: string[] = JournalReaderMachine.splitOnMarkupPiecesAndDates(this.journal);\n    pieces = this.cleansePieces(pieces);\n    this.makeNamesDict(pieces);\n  }\n}\n\n@observer\nexport class Stats extends React.Component<StatsProps>\n{\n  private get machine(): StatsMachine\n  {\n    return this.props.machine as StatsMachine;\n  }\n\n  render()\n  {\n    const x = this.machine.dataFreshness; //ignore\n\n    return <div>\n      <input type=\"text\" id=\"journalInputBox\" onChange={this.machine.onJournalInputChange}/>\n      <button onClick={() => this.machine.makeStats()}>Submit</button>\n\n      <NameCounts namesDict={this.machine.namesDict}/>\n    </div>;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}