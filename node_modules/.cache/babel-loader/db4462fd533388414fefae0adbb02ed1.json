{"ast":null,"code":"import _initializerDefineProperty from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec,\n    _class,\n    _descriptor,\n    _descriptor2,\n    _descriptor3,\n    _descriptor4,\n    _descriptor5,\n    _temp,\n    _class3,\n    _jsxFileName = \"/Users/dirkstahlecker/programming/word-frequencies-heroku/src/AddMarkupToExistingEntry.tsx\";\n\nimport * as React from \"react\";\nimport { observable, action } from \"mobx\";\nimport { observer } from \"mobx-react\";\nimport * as $ from 'jquery';\nimport { NameReference } from \"./NameReference\";\nimport { NamePickerModal, NamePickerModalMachine } from \"./NamePickerModal\";\nimport { MarkupUtils } from \"./MarkupUtils\";\nexport let AddMarkupMachine = (_dec = action.bound, (_class = (_temp = class AddMarkupMachine {\n  constructor() {\n    this.namePickerModalMachine = new NamePickerModalMachine();\n\n    _initializerDefineProperty(this, \"modalResponse\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"currentName\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"oldEntryText\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"updateOldEntryText\", _descriptor4, this);\n\n    this.checkerFunction = () => {\n      if (this.namePickerModalMachine.submitClicked) {}\n\n      return false;\n    };\n\n    _initializerDefineProperty(this, \"handleModalCloseRequest\", _descriptor5, this);\n  }\n\n  static get wordSplitCharacters() {\n    return [\".\", \",\", \"!\", \" \", \"?\", \":\", \";\", \"\\n\", \"'\"];\n  }\n\n  stripWord(inp) {\n    let outputStr = \"\";\n\n    for (let i = 0; i < inp.length; i++) {\n      let c = inp[i];\n\n      if (AddMarkupMachine.wordSplitCharacters.indexOf(c) > -1) {\n        continue;\n      }\n\n      outputStr += c;\n    }\n\n    return outputStr;\n  }\n\n  async startNameSearch(outputText_in = \"\") {\n    // let words: string[] = this.oldEntryText.split(/\\s|\\.|,|:/);\n    // console.log(words);\n    let outputText = outputText_in;\n    let currentWord = \"\";\n\n    for (let i = 0; i < this.oldEntryText.length; i++) {\n      let c = this.oldEntryText[i];\n\n      if (AddMarkupMachine.wordSplitCharacters.indexOf(c) > -1) //boundary\n        {\n          //check if it's a name\n          let word = this.stripWord(currentWord);\n\n          if (NameReference.isName(word)) {\n            //show modal\n            this.modalResponse = null;\n            this.currentName = word; //shows modal\n\n            const modalPromise = new Promise(res => setTimeout(this.checkerFunction, 100));\n            return modalPromise; // const modalPromise = new Promise((resolve, reject) => this.modalResponse != null)\n            // await modalPromise;\n            // this.promiseModal().then(() => console.log(\"After modal\"));\n\n            outputText += this.modalResponse;\n            console.log(outputText); // return this.startNameSearch(outputText);\n          } else {\n            outputText += currentWord;\n          }\n\n          currentWord = \"\";\n        } else //regular letter\n        {\n          currentWord += c;\n        }\n    }\n  } // private promiseModal(): Promise<boolean>\n  // {\n  //   return new Promise((resolve, reject) => {\n  //     <Modal \n  //       isOpen={true}\n  //       onRequestClose={() => resolve(true)}\n  //       contentLabel=\"Example Modal\"\n  //     >\n  //       TEST\n  //     </Modal>\n  //   });\n  // }\n\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"modalResponse\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return null;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"currentName\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return null;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"oldEntryText\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return \"\";\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"updateOldEntryText\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return () => {\n      this.oldEntryText = $(\"#oldEntry\").val();\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"startNameSearch\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"startNameSearch\"), _class.prototype), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"handleModalCloseRequest\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async () => {\n      if (this.currentName == null) {\n        throw Error(\"name shouldn't be null\");\n      } //take the last name given by the user and insert the proper markup into the box itself\n\n\n      const markup = MarkupUtils.makeMarkup(this.currentName, this.namePickerModalMachine.lastName, this.currentName); //add the markup in place of the name\n      //TODO: something here\n      //TODO: need to make modal into a promise we can wait on here\n      //clean up\n\n      this.currentName = null; //close the modal\n\n      this.modalResponse = markup; //triggers the user has submitted the last name\n\n      return Promise.resolve();\n    };\n  }\n})), _class));\nexport let AddMarkupToExistingEntry = observer(_class3 = class AddMarkupToExistingEntry extends React.Component {\n  render() {\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148\n      },\n      __self: this\n    }, React.createElement(NamePickerModal, {\n      machine: this.props.machine.namePickerModalMachine,\n      onRequestClose: () => this.props.machine.handleModalCloseRequest(),\n      isOpen: this.props.machine.currentName != null,\n      currentName: this.props.machine.currentName == null ? \"\" : this.props.machine.currentName,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149\n      },\n      __self: this\n    }), \"Paste old entry here:\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 155\n      },\n      __self: this\n    }), React.createElement(\"textarea\", {\n      id: \"oldEntry\",\n      value: this.props.machine.oldEntryText,\n      onChange: () => this.props.machine.updateOldEntryText(),\n      style: {\n        width: \"90%\",\n        height: \"100px\"\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 156\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      onClick: () => this.props.machine.startNameSearch(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 162\n      },\n      __self: this\n    }, \"Submit\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163\n      },\n      __self: this\n    }));\n  }\n\n}) || _class3;\nexport default AddMarkupToExistingEntry;","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/src/AddMarkupToExistingEntry.tsx"],"names":["React","observable","action","observer","$","NameReference","NamePickerModal","NamePickerModalMachine","MarkupUtils","AddMarkupMachine","bound","namePickerModalMachine","checkerFunction","submitClicked","wordSplitCharacters","stripWord","inp","outputStr","i","length","c","indexOf","startNameSearch","outputText_in","outputText","currentWord","oldEntryText","word","isName","modalResponse","currentName","modalPromise","Promise","res","setTimeout","console","log","val","Error","markup","makeMarkup","lastName","resolve","AddMarkupToExistingEntry","Component","render","props","machine","handleModalCloseRequest","updateOldEntryText","width","height"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {observable, action, runInAction, computed} from \"mobx\";\nimport {observer} from \"mobx-react\";\nimport * as $ from 'jquery';\nimport {NameReference} from \"./NameReference\";\nimport {NamePickerModal, NamePickerModalMachine} from \"./NamePickerModal\";\nimport {MarkupUtils} from \"./MarkupUtils\";\nimport * as Modal from 'react-modal';\n\nexport class AddMarkupMachine\n{\n  public static get wordSplitCharacters(): string[]\n  {\n    return [\".\", \",\", \"!\", \" \", \"?\", \":\", \";\", \"\\n\", \"'\"];\n  }\n\n  public namePickerModalMachine: NamePickerModalMachine = new NamePickerModalMachine();\n\n  @observable\n  public modalResponse: string | null = null;\n\n  @observable\n  public currentName: string | null = null\n\n  @observable\n  public oldEntryText: string = \"\";\n\n  @action\n  public updateOldEntryText = (): void => {\n    this.oldEntryText = $(\"#oldEntry\").val() as string;\n  }\n\n  private stripWord(inp: string): string\n  {\n    let outputStr: string = \"\";\n    for (let i: number = 0; i < inp.length; i++)\n    {\n      let c: string = inp[i];\n      if (AddMarkupMachine.wordSplitCharacters.indexOf(c) > -1)\n      {\n        continue\n      }\n      outputStr += c;\n    }\n    return outputStr;\n  }\n\n  private checkerFunction = (): boolean => {\n    if (this.namePickerModalMachine.submitClicked)\n    {\n      \n    }\n    return false;\n  }\n\n  @action.bound\n  public async startNameSearch(outputText_in: string = \"\"): Promise<void>\n  {\n    // let words: string[] = this.oldEntryText.split(/\\s|\\.|,|:/);\n    // console.log(words);\n    let outputText: string = outputText_in;\n    let currentWord: string = \"\";\n\n    for (let i: number = 0; i < this.oldEntryText.length; i++)\n    {\n      let c: string = this.oldEntryText[i];\n      if (AddMarkupMachine.wordSplitCharacters.indexOf(c) > -1) //boundary\n      {\n        //check if it's a name\n        let word: string = this.stripWord(currentWord);\n        if (NameReference.isName(word))\n        {\n          //show modal\n          this.modalResponse = null;\n          this.currentName = word; //shows modal\n\n          const modalPromise: Promise<void> = new Promise(res => setTimeout(this.checkerFunction, 100));\n          return modalPromise;\n\n          // const modalPromise = new Promise((resolve, reject) => this.modalResponse != null)\n          // await modalPromise;\n\n          // this.promiseModal().then(() => console.log(\"After modal\"));\n\n          outputText += this.modalResponse;\n          console.log(outputText);\n          // return this.startNameSearch(outputText);\n        }\n        else\n        {\n          outputText += currentWord;\n        }\n        currentWord = \"\";\n      }\n      else //regular letter\n      {\n        currentWord += c;\n      }\n    }\n  }\n\n  @action\n  public handleModalCloseRequest = async(): Promise<void> => {\n    if (this.currentName == null)\n    {\n      throw Error(\"name shouldn't be null\");\n    }\n    //take the last name given by the user and insert the proper markup into the box itself\n    const markup: string = MarkupUtils.makeMarkup(this.currentName, this.namePickerModalMachine.lastName, this.currentName);\n    //add the markup in place of the name\n\n    //TODO: something here\n    //TODO: need to make modal into a promise we can wait on here\n\n    //clean up\n    this.currentName = null; //close the modal\n\n    this.modalResponse = markup; //triggers the user has submitted the last name\n    return Promise.resolve();\n  };\n\n  // private promiseModal(): Promise<boolean>\n  // {\n  //   return new Promise((resolve, reject) => {\n  //     <Modal \n  //       isOpen={true}\n  //       onRequestClose={() => resolve(true)}\n  //       contentLabel=\"Example Modal\"\n  //     >\n  //       TEST\n  //     </Modal>\n  //   });\n  // }\n}\n\nexport interface AddMarkupProps\n{\n  machine: AddMarkupMachine\n}\n\n@observer\nexport class AddMarkupToExistingEntry extends React.Component<AddMarkupProps>\n{\n\n\n  render()\n  {\n    return <div>\n      <NamePickerModal \n        machine={this.props.machine.namePickerModalMachine}\n        onRequestClose={() => this.props.machine.handleModalCloseRequest()}\n        isOpen={this.props.machine.currentName != null}\n        currentName={this.props.machine.currentName == null ? \"\" : this.props.machine.currentName}\n      />\n      Paste old entry here:<br />\n      <textarea id=\"oldEntry\" \n                value={this.props.machine.oldEntryText} \n                onChange={() => this.props.machine.updateOldEntryText()}\n                style={{width: \"90%\", height: \"100px\"}}\n      />\n      <br />\n      <button onClick={() => this.props.machine.startNameSearch()}>Submit</button>\n      <br />\n\n    </div>\n    ;\n  }\n}\n\nexport default AddMarkupToExistingEntry;\n"]},"metadata":{},"sourceType":"module"}