{"ast":null,"code":"var parseInt64 = require('pg-int8');\n\nvar parseBits = function (data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n\n  callback = callback || function (lastValue, newValue, bits) {\n    return lastValue * Math.pow(2, bits) + newValue;\n  };\n\n  var offsetBytes = offset >> 3;\n\n  var inv = function (value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  }; // read first (maybe partial) byte\n\n\n  var mask = 0xff;\n  var firstBits = 8 - offset % 8;\n\n  if (bits < firstBits) {\n    mask = 0xff << 8 - bits & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> offset % 8;\n  }\n\n  var result = 0;\n\n  if (offset % 8 + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  } // read bytes\n\n\n  var bytes = bits + offset >> 3;\n\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  } // bits to read, that are not a complete byte\n\n\n  var lastBits = (bits + offset) % 8;\n\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function (data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  } // parse mantissa\n\n\n  var precisionBitsCounter = 1;\n\n  var parsePrecisionBits = function (lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n\n      if ((newValue & 0x1 << bits - i) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits); // special cases\n\n  if (exponent == Math.pow(2, exponentBits + 1) - 1) {\n    if (mantissa === 0) {\n      return sign === 0 ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  } // normale number\n\n\n  return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function (value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function (value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function (value) {\n  var sign = parseBits(value, 16, 32);\n\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + 16 * i) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function (isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1); // discard usecs and shift from 2000 to 1970\n\n  var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  } // add microseconds to the date\n\n\n  result.usec = rawValue % 1000;\n\n  result.getMicroSeconds = function () {\n    return this.usec;\n  };\n\n  result.setMicroSeconds = function (value) {\n    this.usec = value;\n  };\n\n  result.getUTCMicroSeconds = function () {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function (value) {\n  var dim = parseBits(value, 32);\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n  var offset = 96;\n  var dims = [];\n\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32; // ignore lower bounds\n\n    offset += 32;\n  }\n\n  var parseElement = function (elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32; // parse null values\n\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n\n    if (elementType == 0x17 || elementType == 0x14) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    } else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);\n      return result;\n    } else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function (dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n\n      dimension.unshift(count);\n    } else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function (value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function (value) {\n  if (value === null) return null;\n  return parseBits(value, 8) > 0;\n};\n\nvar init = function (register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/pg-types/lib/binaryParsers.js"],"names":["parseInt64","require","parseBits","data","bits","offset","invert","callback","lastValue","newValue","Math","pow","offsetBytes","inv","value","mask","firstBits","result","bytes","i","lastBits","parseFloatFromBits","precisionBits","exponentBits","bias","sign","exponent","precisionBitsCounter","parsePrecisionBits","mantissa","Infinity","NaN","parseInt16","parseInt32","parseFloat32","parseFloat64","parseNumeric","weight","digits","ndigits","scale","round","parseDate","isUTC","rawValue","Date","setTime","getTime","getTimezoneOffset","usec","getMicroSeconds","setMicroSeconds","getUTCMicroSeconds","parseArray","dim","flags","elementType","dims","parseElement","length","toString","encoding","console","log","parse","dimension","array","count","shift","unshift","parseText","parseBool","init","register","bind","module","exports"],"mappings":"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","sourcesContent":["var parseInt64 = require('pg-int8');\n\nvar parseBits = function(data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };\n  var offsetBytes = offset >> 3;\n\n  var inv = function(value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  };\n\n  // read first (maybe partial) byte\n  var mask = 0xff;\n  var firstBits = 8 - (offset % 8);\n  if (bits < firstBits) {\n    mask = (0xff << (8 - bits)) & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> (offset % 8);\n  }\n\n  var result = 0;\n  if ((offset % 8) + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  }\n\n  // read bytes\n  var bytes = (bits + offset) >> 3;\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  }\n\n  // bits to read, that are not a complete byte\n  var lastBits = (bits + offset) % 8;\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function(data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  }\n\n  // parse mantissa\n  var precisionBitsCounter = 1;\n  var parsePrecisionBits = function(lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n      if ((newValue & (0x1 << (bits - i))) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);\n\n  // special cases\n  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {\n    if (mantissa === 0) {\n      return (sign === 0) ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  }\n\n  // normale number\n  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function(value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function(value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function(value) {\n  var sign = parseBits(value, 16, 32);\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + (16 * i)) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function(isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1);\n\n  // discard usecs and shift from 2000 to 1970\n  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  }\n\n  // add microseconds to the date\n  result.usec = rawValue % 1000;\n  result.getMicroSeconds = function() {\n    return this.usec;\n  };\n  result.setMicroSeconds = function(value) {\n    this.usec = value;\n  };\n  result.getUTCMicroSeconds = function() {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function(value) {\n  var dim = parseBits(value, 32);\n\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n\n  var offset = 96;\n  var dims = [];\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32;\n\n    // ignore lower bounds\n    offset += 32;\n  }\n\n  var parseElement = function(elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32;\n\n    // parse null values\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n    if ((elementType == 0x17) || (elementType == 0x14)) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    }\n    else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);\n      return result;\n    }\n    else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function(dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n      dimension.unshift(count);\n    }\n    else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function(value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function(value) {\n  if(value === null) return null;\n  return (parseBits(value, 8) > 0);\n};\n\nvar init = function(register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};\n"]},"metadata":{},"sourceType":"script"}