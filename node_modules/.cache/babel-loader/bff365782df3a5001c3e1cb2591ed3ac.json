{"ast":null,"code":"import { Markup } from \"./Markup\"; // export class NamesDB\n// {\n//   private namesDict: Set<WordInfo> = new Set();\n// }\n\nexport class WordInfo {\n  constructor(word, count, date) {\n    this._word = void 0;\n    this._count = void 0;\n    this._dates = new Set();\n    this._word = word;\n    this._count = count;\n\n    if (date !== undefined) {\n      this.addDate(date);\n    }\n  }\n\n  get word() {\n    return this._word;\n  }\n\n  set word(value) {\n    this._word = value;\n  }\n\n  get count() {\n    return this._count;\n  }\n\n  set count(value) {\n    this._count = value;\n  }\n\n  get dates() {\n    return this._dates;\n  }\n\n  addDate(date) {\n    this._dates.add(date);\n  }\n\n  clearDates() {\n    this._dates.clear();\n  }\n\n  getSortedDates() {\n    const sortedArray = Array.from(this._dates).sort((a, b) => {\n      return a.getTime() - b.getTime();\n    });\n    return sortedArray;\n  }\n\n  getFirstDate() {\n    return this.getSortedDates()[0];\n  }\n\n  getLastDate() {\n    const sortedDates = this.getSortedDates();\n    return sortedDates[sortedDates.length - 1];\n  }\n\n} //word is firstName_lastName\n\nexport class NameInfo extends WordInfo {\n  constructor(markup, count, date) {\n    if (!Markup.isMarkup(word)) {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n\n    super(markup.getKey(), count, date);\n    this.displayNames = void 0;\n    this.displayNames = [markup.displayName];\n  }\n\n  set word(value) {\n    if (!Markup.isMarkup(value)) {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n\n    this._word = value;\n  }\n\n  get word() {\n    //we know it's markup since it's checked in the setter\n    return Markup.create(this._word).displayName;\n  }\n\n  get markup() {\n    return Markup.create(this._word);\n  }\n\n  addDisplayName(displayName) {} //display name doesn't matter - only first and last name pair is unique\n\n\n  static equals(a, b) {\n    return a.markup.firstName === b.markup.firstName && a.markup.lastName === b.markup.lastName;\n  } //key is used as the map key to group unique first/last name pairs regardless\n  //of display names\n\n\n  getKey() {\n    return this.markup.firstName + \"_\" + this.markup.lastName;\n  }\n\n}","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/src/stats/NamesDB.ts"],"names":["Markup","WordInfo","constructor","word","count","date","_word","_count","_dates","Set","undefined","addDate","value","dates","add","clearDates","clear","getSortedDates","sortedArray","Array","from","sort","a","b","getTime","getFirstDate","getLastDate","sortedDates","length","NameInfo","markup","isMarkup","Error","getKey","displayNames","displayName","create","addDisplayName","equals","firstName","lastName"],"mappings":"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","sourcesContent":["import {Markup} from \"./Markup\";\n\n// export class NamesDB\n// {\n//   private namesDict: Set<WordInfo> = new Set();\n// }\n\nexport class WordInfo\n{\n  protected _word: string;\n  protected _count: number;\n  protected _dates: Set<Date> = new Set();\n\n  constructor(word: string, count: number, date?: Date)\n  {\n    this._word = word;\n    this._count = count;\n    if (date !== undefined)\n    {\n      this.addDate(date);\n    }\n  }\n\n  public get word(): string\n  {\n    return this._word;\n  }\n\n  public set word(value: string)\n  {\n    this._word = value;\n  }\n\n  public get count(): number\n  {\n    return this._count;\n  }\n\n  public set count(value: number)\n  {\n    this._count = value;\n  }\n\n  public get dates(): Set<Date>\n  {\n    return this._dates;\n  }\n\n  public addDate(date: Date): void\n  {\n    this._dates.add(date);\n  }\n\n  public clearDates(): void\n  {\n    this._dates.clear();\n  }\n\n  private getSortedDates(): Date[]\n  {\n    const sortedArray = Array.from(this._dates).sort((a: Date, b: Date) => {\n      return a.getTime() - b.getTime();\n    });\n    return sortedArray;\n  }\n\n  public getFirstDate(): Date\n  {\n    return this.getSortedDates()[0];\n  }\n\n  public getLastDate(): Date\n  {\n    const sortedDates: Date[] = this.getSortedDates();\n    return sortedDates[sortedDates.length - 1];\n  }\n}\n\n//word is firstName_lastName\nexport class NameInfo extends WordInfo\n{\n  constructor(markup: string, count: number, date?: Date)\n  {\n    if (!Markup.isMarkup(word))\n    {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n    super(markup.getKey(), count, date);\n    this.displayNames = [markup.displayName];\n  }\n\n  public displayNames: string[];\n\n  public set word(value: string)\n  {\n    if (!Markup.isMarkup(value))\n    {\n      throw Error(\"Must be valid markup to be a NameInfo\");\n    }\n    this._word = value;\n  }\n\n  public get word(): string\n  {\n    //we know it's markup since it's checked in the setter\n    return Markup.create(this._word).displayName;\n  }\n\n  public get markup(): Markup\n  {\n    return Markup.create(this._word)\n  }\n\n  public addDisplayName(displayName: string): void\n  {\n\n  }\n\n  //display name doesn't matter - only first and last name pair is unique\n  public static equals(a: NameInfo, b: NameInfo)\n  {\n    return a.markup.firstName === b.markup.firstName\n        && a.markup.lastName === b.markup.lastName;\n  }\n\n  //key is used as the map key to group unique first/last name pairs regardless\n  //of display names\n  public getKey(): string\n  {\n    return this.markup.firstName + \"_\" + this.markup.lastName;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}