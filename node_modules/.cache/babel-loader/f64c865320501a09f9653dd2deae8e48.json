{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nconst checkConstructor = require('./compat/check-constructor');\n\nvar Result = require('./result');\n\nvar utils = require('./utils');\n\nvar Query = function (config, values, callback) {\n  // use of \"new\" optional in pg 7\n  // eslint-disable-next-line no-eval\n  checkConstructor('Query', 'PG-QUERY-NEW', () => eval('new.target'));\n\n  if (!(this instanceof Query)) {\n    return new Query(config, values, callback);\n  }\n\n  config = utils.normalizeQueryConfig(config, values, callback);\n  this.text = config.text;\n  this.values = config.values;\n  this.rows = config.rows;\n  this.types = config.types;\n  this.name = config.name;\n  this.binary = config.binary; // use unique portal name each time\n\n  this.portal = config.portal || '';\n  this.callback = config.callback;\n  this._rowMode = config.rowMode;\n\n  if (process.domain && config.callback) {\n    this.callback = process.domain.bind(config.callback);\n  }\n\n  this._result = new Result(this._rowMode, this.types); // potential for multiple results\n\n  this._results = this._result;\n  this.isPreparedStatement = false;\n  this._canceledDueToError = false;\n  this._promise = null;\n  EventEmitter.call(this);\n};\n\nutil.inherits(Query, EventEmitter);\n\nQuery.prototype.requiresPreparation = function () {\n  // named queries must always be prepared\n  if (this.name) {\n    return true;\n  } // always prepare if there are max number of rows expected per\n  // portal execution\n\n\n  if (this.rows) {\n    return true;\n  } // don't prepare empty text queries\n\n\n  if (!this.text) {\n    return false;\n  } // prepare if there are values\n\n\n  if (!this.values) {\n    return false;\n  }\n\n  return this.values.length > 0;\n};\n\nQuery.prototype._checkForMultirow = function () {\n  // if we already have a result with a command property\n  // then we've already executed one query in a multi-statement simple query\n  // turn our results into an array of results\n  if (this._result.command) {\n    if (!Array.isArray(this._results)) {\n      this._results = [this._result];\n    }\n\n    this._result = new Result(this._rowMode, this.types);\n\n    this._results.push(this._result);\n  }\n}; // associates row metadata from the supplied\n// message with this query object\n// metadata used when parsing row results\n\n\nQuery.prototype.handleRowDescription = function (msg) {\n  this._checkForMultirow();\n\n  this._result.addFields(msg.fields);\n\n  this._accumulateRows = this.callback || !this.listeners('row').length;\n};\n\nQuery.prototype.handleDataRow = function (msg) {\n  var row;\n\n  if (this._canceledDueToError) {\n    return;\n  }\n\n  try {\n    row = this._result.parseRow(msg.fields);\n  } catch (err) {\n    this._canceledDueToError = err;\n    return;\n  }\n\n  this.emit('row', row, this._result);\n\n  if (this._accumulateRows) {\n    this._result.addRow(row);\n  }\n};\n\nQuery.prototype.handleCommandComplete = function (msg, con) {\n  this._checkForMultirow();\n\n  this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement\n\n\n  if (this.isPreparedStatement) {\n    con.sync();\n  }\n}; // if a named prepared statement is created with empty query text\n// the backend will send an emptyQuery message but *not* a command complete message\n// execution on the connection will hang until the backend receives a sync message\n\n\nQuery.prototype.handleEmptyQuery = function (con) {\n  if (this.isPreparedStatement) {\n    con.sync();\n  }\n};\n\nQuery.prototype.handleReadyForQuery = function (con) {\n  if (this._canceledDueToError) {\n    return this.handleError(this._canceledDueToError, con);\n  }\n\n  if (this.callback) {\n    this.callback(null, this._results);\n  }\n\n  this.emit('end', this._results);\n};\n\nQuery.prototype.handleError = function (err, connection) {\n  // need to sync after error during a prepared statement\n  if (this.isPreparedStatement) {\n    connection.sync();\n  }\n\n  if (this._canceledDueToError) {\n    err = this._canceledDueToError;\n    this._canceledDueToError = false;\n  } // if callback supplied do not emit error event as uncaught error\n  // events will bubble up to node process\n\n\n  if (this.callback) {\n    return this.callback(err);\n  }\n\n  this.emit('error', err);\n};\n\nQuery.prototype.submit = function (connection) {\n  if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n    return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n  }\n\n  const previous = connection.parsedStatements[this.name];\n\n  if (this.text && previous && this.text !== previous) {\n    return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);\n  }\n\n  if (this.values && !Array.isArray(this.values)) {\n    return new Error('Query values must be an array');\n  }\n\n  if (this.requiresPreparation()) {\n    this.prepare(connection);\n  } else {\n    connection.query(this.text);\n  }\n\n  return null;\n};\n\nQuery.prototype.hasBeenParsed = function (connection) {\n  return this.name && connection.parsedStatements[this.name];\n};\n\nQuery.prototype.handlePortalSuspended = function (connection) {\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype._getRows = function (connection, rows) {\n  connection.execute({\n    portal: this.portal,\n    rows: rows\n  }, true);\n  connection.flush();\n};\n\nQuery.prototype.prepare = function (connection) {\n  var self = this; // prepared statements need sync to be called after each command\n  // complete or when an error is encountered\n\n  this.isPreparedStatement = true; // TODO refactor this poor encapsulation\n\n  if (!this.hasBeenParsed(connection)) {\n    connection.parse({\n      text: self.text,\n      name: self.name,\n      types: self.types\n    }, true);\n  }\n\n  if (self.values) {\n    try {\n      self.values = self.values.map(utils.prepareValue);\n    } catch (err) {\n      this.handleError(err, connection);\n      return;\n    }\n  } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n\n\n  connection.bind({\n    portal: self.portal,\n    statement: self.name,\n    values: self.values,\n    binary: self.binary\n  }, true);\n  connection.describe({\n    type: 'P',\n    name: self.portal || ''\n  }, true);\n\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype.handleCopyInResponse = function (connection) {\n  connection.sendCopyFail('No source stream defined');\n}; // eslint-disable-next-line no-unused-vars\n\n\nQuery.prototype.handleCopyData = function (msg, connection) {// noop\n};\n\nmodule.exports = Query;","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/pg/lib/query.js"],"names":["EventEmitter","require","util","checkConstructor","Result","utils","Query","config","values","callback","eval","normalizeQueryConfig","text","rows","types","name","binary","portal","_rowMode","rowMode","process","domain","bind","_result","_results","isPreparedStatement","_canceledDueToError","_promise","call","inherits","prototype","requiresPreparation","length","_checkForMultirow","command","Array","isArray","push","handleRowDescription","msg","addFields","fields","_accumulateRows","listeners","handleDataRow","row","parseRow","err","emit","addRow","handleCommandComplete","con","addCommandComplete","sync","handleEmptyQuery","handleReadyForQuery","handleError","connection","submit","Error","previous","parsedStatements","prepare","query","hasBeenParsed","handlePortalSuspended","_getRows","execute","flush","self","parse","map","prepareValue","statement","describe","type","handleCopyInResponse","sendCopyFail","handleCopyData","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nconst checkConstructor = require('./compat/check-constructor')\n\nvar Result = require('./result')\nvar utils = require('./utils')\n\nvar Query = function (config, values, callback) {\n  // use of \"new\" optional in pg 7\n  // eslint-disable-next-line no-eval\n  checkConstructor('Query', 'PG-QUERY-NEW', () => eval('new.target'))\n  if (!(this instanceof Query)) { return new Query(config, values, callback) }\n\n  config = utils.normalizeQueryConfig(config, values, callback)\n\n  this.text = config.text\n  this.values = config.values\n  this.rows = config.rows\n  this.types = config.types\n  this.name = config.name\n  this.binary = config.binary\n  // use unique portal name each time\n  this.portal = config.portal || ''\n  this.callback = config.callback\n  this._rowMode = config.rowMode\n  if (process.domain && config.callback) {\n    this.callback = process.domain.bind(config.callback)\n  }\n  this._result = new Result(this._rowMode, this.types)\n\n  // potential for multiple results\n  this._results = this._result\n  this.isPreparedStatement = false\n  this._canceledDueToError = false\n  this._promise = null\n  EventEmitter.call(this)\n}\n\nutil.inherits(Query, EventEmitter)\n\nQuery.prototype.requiresPreparation = function () {\n  // named queries must always be prepared\n  if (this.name) { return true }\n  // always prepare if there are max number of rows expected per\n  // portal execution\n  if (this.rows) { return true }\n  // don't prepare empty text queries\n  if (!this.text) { return false }\n  // prepare if there are values\n  if (!this.values) { return false }\n  return this.values.length > 0\n}\n\nQuery.prototype._checkForMultirow = function () {\n  // if we already have a result with a command property\n  // then we've already executed one query in a multi-statement simple query\n  // turn our results into an array of results\n  if (this._result.command) {\n    if (!Array.isArray(this._results)) {\n      this._results = [this._result]\n    }\n    this._result = new Result(this._rowMode, this.types)\n    this._results.push(this._result)\n  }\n}\n\n// associates row metadata from the supplied\n// message with this query object\n// metadata used when parsing row results\nQuery.prototype.handleRowDescription = function (msg) {\n  this._checkForMultirow()\n  this._result.addFields(msg.fields)\n  this._accumulateRows = this.callback || !this.listeners('row').length\n}\n\nQuery.prototype.handleDataRow = function (msg) {\n  var row\n\n  if (this._canceledDueToError) {\n    return\n  }\n\n  try {\n    row = this._result.parseRow(msg.fields)\n  } catch (err) {\n    this._canceledDueToError = err\n    return\n  }\n\n  this.emit('row', row, this._result)\n  if (this._accumulateRows) {\n    this._result.addRow(row)\n  }\n}\n\nQuery.prototype.handleCommandComplete = function (msg, con) {\n  this._checkForMultirow()\n  this._result.addCommandComplete(msg)\n  // need to sync after each command complete of a prepared statement\n  if (this.isPreparedStatement) {\n    con.sync()\n  }\n}\n\n// if a named prepared statement is created with empty query text\n// the backend will send an emptyQuery message but *not* a command complete message\n// execution on the connection will hang until the backend receives a sync message\nQuery.prototype.handleEmptyQuery = function (con) {\n  if (this.isPreparedStatement) {\n    con.sync()\n  }\n}\n\nQuery.prototype.handleReadyForQuery = function (con) {\n  if (this._canceledDueToError) {\n    return this.handleError(this._canceledDueToError, con)\n  }\n  if (this.callback) {\n    this.callback(null, this._results)\n  }\n  this.emit('end', this._results)\n}\n\nQuery.prototype.handleError = function (err, connection) {\n  // need to sync after error during a prepared statement\n  if (this.isPreparedStatement) {\n    connection.sync()\n  }\n  if (this._canceledDueToError) {\n    err = this._canceledDueToError\n    this._canceledDueToError = false\n  }\n  // if callback supplied do not emit error event as uncaught error\n  // events will bubble up to node process\n  if (this.callback) {\n    return this.callback(err)\n  }\n  this.emit('error', err)\n}\n\nQuery.prototype.submit = function (connection) {\n  if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n    return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n  }\n  const previous = connection.parsedStatements[this.name]\n  if (this.text && previous && this.text !== previous) {\n    return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n  }\n  if (this.values && !Array.isArray(this.values)) {\n    return new Error('Query values must be an array')\n  }\n  if (this.requiresPreparation()) {\n    this.prepare(connection)\n  } else {\n    connection.query(this.text)\n  }\n  return null\n}\n\nQuery.prototype.hasBeenParsed = function (connection) {\n  return this.name && connection.parsedStatements[this.name]\n}\n\nQuery.prototype.handlePortalSuspended = function (connection) {\n  this._getRows(connection, this.rows)\n}\n\nQuery.prototype._getRows = function (connection, rows) {\n  connection.execute({\n    portal: this.portal,\n    rows: rows\n  }, true)\n  connection.flush()\n}\n\nQuery.prototype.prepare = function (connection) {\n  var self = this\n  // prepared statements need sync to be called after each command\n  // complete or when an error is encountered\n  this.isPreparedStatement = true\n  // TODO refactor this poor encapsulation\n  if (!this.hasBeenParsed(connection)) {\n    connection.parse({\n      text: self.text,\n      name: self.name,\n      types: self.types\n    }, true)\n  }\n\n  if (self.values) {\n    try {\n      self.values = self.values.map(utils.prepareValue)\n    } catch (err) {\n      this.handleError(err, connection)\n      return\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  connection.bind({\n    portal: self.portal,\n    statement: self.name,\n    values: self.values,\n    binary: self.binary\n  }, true)\n\n  connection.describe({\n    type: 'P',\n    name: self.portal || ''\n  }, true)\n\n  this._getRows(connection, this.rows)\n}\n\nQuery.prototype.handleCopyInResponse = function (connection) {\n  connection.sendCopyFail('No source stream defined')\n}\n\n// eslint-disable-next-line no-unused-vars\nQuery.prototype.handleCopyData = function (msg, connection) {\n  // noop\n}\nmodule.exports = Query\n"]},"metadata":{},"sourceType":"script"}