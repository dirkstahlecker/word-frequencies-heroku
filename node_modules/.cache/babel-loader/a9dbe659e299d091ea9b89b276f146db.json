{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nfunction startSession(mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported');\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64');\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  };\n}\n\nfunction continueSession(session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse');\n  }\n\n  const sv = extractVariablesFromFirstServerMessage(serverData);\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce');\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64');\n  var saltedPassword = Hi(password, saltBytes, sv.iteration);\n  var clientKey = createHMAC(saltedPassword, 'Client Key');\n  var storedKey = crypto.createHash('sha256').update(clientKey).digest();\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce;\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce;\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;\n  var clientSignature = createHMAC(storedKey, authMessage);\n  var clientProofBytes = xorBuffers(clientKey, clientSignature);\n  var clientProof = clientProofBytes.toString('base64');\n  var serverKey = createHMAC(saltedPassword, 'Server Key');\n  var serverSignatureBytes = createHMAC(serverKey, authMessage);\n  session.message = 'SASLResponse';\n  session.serverSignature = serverSignatureBytes.toString('base64');\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse');\n  }\n\n  var serverSignature;\n  String(serverData).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'v':\n        serverSignature = part.substr(2);\n        break;\n    }\n  });\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match');\n  }\n}\n\nfunction extractVariablesFromFirstServerMessage(data) {\n  var nonce, salt, iteration;\n  String(data).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'r':\n        nonce = part.substr(2);\n        break;\n\n      case 's':\n        salt = part.substr(2);\n        break;\n\n      case 'i':\n        iteration = parseInt(part.substr(2), 10);\n        break;\n    }\n  });\n\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing');\n  }\n\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing');\n  }\n\n  if (!iteration) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing');\n  }\n\n  return {\n    nonce,\n    salt,\n    iteration\n  };\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  var res = [];\n\n  if (a.length > b.length) {\n    for (var i = 0; i < b.length; i++) {\n      res.push(a[i] ^ b[i]);\n    }\n  } else {\n    for (var j = 0; j < a.length; j++) {\n      res.push(a[j] ^ b[j]);\n    }\n  }\n\n  return Buffer.from(res);\n}\n\nfunction createHMAC(key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest();\n}\n\nfunction Hi(password, saltBytes, iterations) {\n  var ui1 = createHMAC(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]));\n  var ui = ui1;\n\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = createHMAC(password, ui1);\n    ui = xorBuffers(ui, ui1);\n  }\n\n  return ui;\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession\n};","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/pg/lib/sasl.js"],"names":["crypto","require","startSession","mechanisms","indexOf","Error","clientNonce","randomBytes","toString","mechanism","response","message","continueSession","session","password","serverData","sv","extractVariablesFromFirstServerMessage","nonce","startsWith","saltBytes","Buffer","from","salt","saltedPassword","Hi","iteration","clientKey","createHMAC","storedKey","createHash","update","digest","clientFirstMessageBare","serverFirstMessage","clientFinalMessageWithoutProof","authMessage","clientSignature","clientProofBytes","xorBuffers","clientProof","serverKey","serverSignatureBytes","serverSignature","finalizeSession","String","split","forEach","part","substr","data","parseInt","a","b","isBuffer","res","length","i","push","j","key","msg","createHmac","iterations","ui1","concat","ui","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst crypto = require('crypto')\n\nfunction startSession (mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported')\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64')\n\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  }\n}\n\nfunction continueSession (session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse')\n  }\n\n  const sv = extractVariablesFromFirstServerMessage(serverData)\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64')\n\n  var saltedPassword = Hi(password, saltBytes, sv.iteration)\n\n  var clientKey = createHMAC(saltedPassword, 'Client Key')\n  var storedKey = crypto.createHash('sha256').update(clientKey).digest()\n\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration\n\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce\n\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof\n\n  var clientSignature = createHMAC(storedKey, authMessage)\n  var clientProofBytes = xorBuffers(clientKey, clientSignature)\n  var clientProof = clientProofBytes.toString('base64')\n\n  var serverKey = createHMAC(saltedPassword, 'Server Key')\n  var serverSignatureBytes = createHMAC(serverKey, authMessage)\n\n  session.message = 'SASLResponse'\n  session.serverSignature = serverSignatureBytes.toString('base64')\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof\n}\n\nfunction finalizeSession (session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse')\n  }\n\n  var serverSignature\n\n  String(serverData).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'v':\n        serverSignature = part.substr(2)\n        break\n    }\n  })\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')\n  }\n}\n\nfunction extractVariablesFromFirstServerMessage (data) {\n  var nonce, salt, iteration\n\n  String(data).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'r':\n        nonce = part.substr(2)\n        break\n      case 's':\n        salt = part.substr(2)\n        break\n      case 'i':\n        iteration = parseInt(part.substr(2), 10)\n        break\n    }\n  })\n\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')\n  }\n\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')\n  }\n\n  if (!iteration) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')\n  }\n\n  return {\n    nonce,\n    salt,\n    iteration\n  }\n}\n\nfunction xorBuffers (a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a)\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b)\n  var res = []\n  if (a.length > b.length) {\n    for (var i = 0; i < b.length; i++) {\n      res.push(a[i] ^ b[i])\n    }\n  } else {\n    for (var j = 0; j < a.length; j++) {\n      res.push(a[j] ^ b[j])\n    }\n  }\n  return Buffer.from(res)\n}\n\nfunction createHMAC (key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest()\n}\n\nfunction Hi (password, saltBytes, iterations) {\n  var ui1 = createHMAC(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]))\n  var ui = ui1\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = createHMAC(password, ui1)\n    ui = xorBuffers(ui, ui1)\n  }\n\n  return ui\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession\n}\n"]},"metadata":{},"sourceType":"script"}