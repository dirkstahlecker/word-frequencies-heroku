{"ast":null,"code":"var assert = require('assert');\n\nvar Reader = module.exports = function (options) {\n  //TODO - remove for version 1.0\n  if (typeof options == 'number') {\n    options = {\n      headerSize: options\n    };\n  }\n\n  options = options || {};\n  this.offset = 0;\n  this.lastChunk = false;\n  this.chunk = null;\n  this.chunkLength = 0;\n  this.headerSize = options.headerSize || 0;\n  this.lengthPadding = options.lengthPadding || 0;\n  this.header = null;\n  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported');\n};\n\nReader.prototype.addChunk = function (chunk) {\n  if (!this.chunk || this.offset === this.chunkLength) {\n    this.chunk = chunk;\n    this.chunkLength = chunk.length;\n    this.offset = 0;\n    return;\n  }\n\n  var newChunkLength = chunk.length;\n  var newLength = this.chunkLength + newChunkLength;\n\n  if (newLength > this.chunk.length) {\n    var newBufferLength = this.chunk.length * 2;\n\n    while (newLength >= newBufferLength) {\n      newBufferLength *= 2;\n    }\n\n    var newBuffer = Buffer.alloc(newBufferLength);\n    this.chunk.copy(newBuffer);\n    this.chunk = newBuffer;\n  }\n\n  chunk.copy(this.chunk, this.chunkLength);\n  this.chunkLength = newLength;\n};\n\nReader.prototype.read = function () {\n  if (this.chunkLength < this.headerSize + 4 + this.offset) {\n    return false;\n  }\n\n  if (this.headerSize) {\n    this.header = this.chunk[this.offset];\n  } //read length of next item\n\n\n  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding; //next item spans more chunks than we have\n\n  var remaining = this.chunkLength - (this.offset + 4 + this.headerSize);\n\n  if (length > remaining) {\n    return false;\n  }\n\n  this.offset += this.headerSize + 4;\n  var result = this.chunk.slice(this.offset, this.offset + length);\n  this.offset += length;\n  return result;\n};","map":{"version":3,"sources":["/Users/dirkstahlecker/programming/word-frequencies-heroku/node_modules/packet-reader/index.js"],"names":["assert","require","Reader","module","exports","options","headerSize","offset","lastChunk","chunk","chunkLength","lengthPadding","header","prototype","addChunk","length","newChunkLength","newLength","newBufferLength","newBuffer","Buffer","alloc","copy","read","readUInt32BE","remaining","result","slice"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIC,MAAM,GAAGC,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AAC9C;AACA,MAAG,OAAOA,OAAP,IAAkB,QAArB,EAA+B;AAC7BA,IAAAA,OAAO,GAAG;AAAEC,MAAAA,UAAU,EAAED;AAAd,KAAV;AACD;;AACDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,OAAKE,MAAL,GAAc,CAAd;AACA,OAAKC,SAAL,GAAiB,KAAjB;AACA,OAAKC,KAAL,GAAa,IAAb;AACA,OAAKC,WAAL,GAAmB,CAAnB;AACA,OAAKJ,UAAL,GAAkBD,OAAO,CAACC,UAAR,IAAsB,CAAxC;AACA,OAAKK,aAAL,GAAqBN,OAAO,CAACM,aAAR,IAAyB,CAA9C;AACA,OAAKC,MAAL,GAAc,IAAd;AACAZ,EAAAA,MAAM,CAAC,KAAKM,UAAL,GAAkB,CAAnB,EAAsB,sEAAtB,CAAN;AACD,CAdD;;AAgBAJ,MAAM,CAACW,SAAP,CAAiBC,QAAjB,GAA4B,UAASL,KAAT,EAAgB;AAC1C,MAAI,CAAC,KAAKA,KAAN,IAAe,KAAKF,MAAL,KAAgB,KAAKG,WAAxC,EAAqD;AACnD,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,WAAL,GAAmBD,KAAK,CAACM,MAAzB;AACA,SAAKR,MAAL,GAAc,CAAd;AACA;AACD;;AAED,MAAIS,cAAc,GAAGP,KAAK,CAACM,MAA3B;AACA,MAAIE,SAAS,GAAG,KAAKP,WAAL,GAAmBM,cAAnC;;AAEA,MAAIC,SAAS,GAAG,KAAKR,KAAL,CAAWM,MAA3B,EAAmC;AACjC,QAAIG,eAAe,GAAG,KAAKT,KAAL,CAAWM,MAAX,GAAoB,CAA1C;;AACA,WAAOE,SAAS,IAAIC,eAApB,EAAqC;AACnCA,MAAAA,eAAe,IAAI,CAAnB;AACD;;AACD,QAAIC,SAAS,GAAGC,MAAM,CAACC,KAAP,CAAaH,eAAb,CAAhB;AACA,SAAKT,KAAL,CAAWa,IAAX,CAAgBH,SAAhB;AACA,SAAKV,KAAL,GAAaU,SAAb;AACD;;AACDV,EAAAA,KAAK,CAACa,IAAN,CAAW,KAAKb,KAAhB,EAAuB,KAAKC,WAA5B;AACA,OAAKA,WAAL,GAAmBO,SAAnB;AACD,CAtBD;;AAwBAf,MAAM,CAACW,SAAP,CAAiBU,IAAjB,GAAwB,YAAW;AACjC,MAAG,KAAKb,WAAL,GAAoB,KAAKJ,UAAL,GAAkB,CAAlB,GAAsB,KAAKC,MAAlD,EAA2D;AACzD,WAAO,KAAP;AACD;;AAED,MAAG,KAAKD,UAAR,EAAoB;AAClB,SAAKM,MAAL,GAAc,KAAKH,KAAL,CAAW,KAAKF,MAAhB,CAAd;AACD,GAPgC,CASjC;;;AACA,MAAIQ,MAAM,GAAG,KAAKN,KAAL,CAAWe,YAAX,CAAwB,KAAKjB,MAAL,GAAc,KAAKD,UAA3C,IAAyD,KAAKK,aAA3E,CAViC,CAYjC;;AACA,MAAIc,SAAS,GAAG,KAAKf,WAAL,IAAoB,KAAKH,MAAL,GAAc,CAAd,GAAkB,KAAKD,UAA3C,CAAhB;;AACA,MAAGS,MAAM,GAAGU,SAAZ,EAAuB;AACrB,WAAO,KAAP;AACD;;AAED,OAAKlB,MAAL,IAAgB,KAAKD,UAAL,GAAkB,CAAlC;AACA,MAAIoB,MAAM,GAAG,KAAKjB,KAAL,CAAWkB,KAAX,CAAiB,KAAKpB,MAAtB,EAA8B,KAAKA,MAAL,GAAcQ,MAA5C,CAAb;AACA,OAAKR,MAAL,IAAeQ,MAAf;AACA,SAAOW,MAAP;AACD,CAtBD","sourcesContent":["var assert = require('assert')\n\nvar Reader = module.exports = function(options) {\n  //TODO - remove for version 1.0\n  if(typeof options == 'number') {\n    options = { headerSize: options }\n  }\n  options = options || {}\n  this.offset = 0\n  this.lastChunk = false\n  this.chunk = null\n  this.chunkLength = 0\n  this.headerSize = options.headerSize || 0\n  this.lengthPadding = options.lengthPadding || 0\n  this.header = null\n  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported')\n}\n\nReader.prototype.addChunk = function(chunk) {\n  if (!this.chunk || this.offset === this.chunkLength) {\n    this.chunk = chunk\n    this.chunkLength = chunk.length\n    this.offset = 0\n    return\n  }\n\n  var newChunkLength = chunk.length\n  var newLength = this.chunkLength + newChunkLength\n\n  if (newLength > this.chunk.length) {\n    var newBufferLength = this.chunk.length * 2\n    while (newLength >= newBufferLength) {\n      newBufferLength *= 2\n    }\n    var newBuffer = Buffer.alloc(newBufferLength)\n    this.chunk.copy(newBuffer)\n    this.chunk = newBuffer\n  }\n  chunk.copy(this.chunk, this.chunkLength)\n  this.chunkLength = newLength\n}\n\nReader.prototype.read = function() {\n  if(this.chunkLength < (this.headerSize + 4 + this.offset)) {\n    return false\n  }\n\n  if(this.headerSize) {\n    this.header = this.chunk[this.offset]\n  }\n\n  //read length of next item\n  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding\n\n  //next item spans more chunks than we have\n  var remaining = this.chunkLength - (this.offset + 4 + this.headerSize)\n  if(length > remaining) {\n    return false\n  }\n\n  this.offset += (this.headerSize + 4)\n  var result = this.chunk.slice(this.offset, this.offset + length)\n  this.offset += length\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}