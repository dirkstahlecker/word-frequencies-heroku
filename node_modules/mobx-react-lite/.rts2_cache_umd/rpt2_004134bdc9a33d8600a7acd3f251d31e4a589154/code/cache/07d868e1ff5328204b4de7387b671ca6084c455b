{"code":"import { Reaction } from \"mobx\";\r\nimport React from \"react\";\r\nimport { printDebugValue } from \"./printDebugValue\";\r\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\r\nimport { isUsingStaticRendering } from \"./staticRendering\";\r\nimport { useForceUpdate } from \"./utils\";\r\nconst EMPTY_OBJECT = {};\r\nfunction observerComponentNameFor(baseComponentName) {\r\n    return `observer${baseComponentName}`;\r\n}\r\nexport function useObserver(fn, baseComponentName = \"observed\", options = EMPTY_OBJECT) {\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    const wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\r\n    const forceUpdate = wantedForceUpdateHook();\r\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\r\n    // rendered and abandoned multiple times, so we need to track leaked\r\n    // Reactions.\r\n    const reactionTrackingRef = React.useRef(null);\r\n    if (!reactionTrackingRef.current) {\r\n        // First render for this component (or first time since a previous\r\n        // reaction from an abandoned render was disposed).\r\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n            // Observable has changed, meaning we want to re-render\r\n            // BUT if we're a component that hasn't yet got to the useEffect()\r\n            // stage, we might be a component that _started_ to render, but\r\n            // got dropped, and we don't want to make state changes then.\r\n            // (It triggers warnings in StrictMode, for a start.)\r\n            if (trackingData.mounted) {\r\n                // We have reached useEffect(), so we're mounted, and can trigger an update\r\n                forceUpdate();\r\n            }\r\n            else {\r\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\r\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\r\n                // drop our current reaction and allow useEffect() to recreate it.\r\n                newReaction.dispose();\r\n                reactionTrackingRef.current = null;\r\n            }\r\n        });\r\n        const trackingData = createTrackingData(newReaction);\r\n        reactionTrackingRef.current = trackingData;\r\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\r\n    }\r\n    const { reaction } = reactionTrackingRef.current;\r\n    React.useDebugValue(reaction, printDebugValue);\r\n    React.useEffect(() => {\r\n        // Called on first mount only\r\n        recordReactionAsCommitted(reactionTrackingRef);\r\n        if (reactionTrackingRef.current) {\r\n            // Great. We've already got our reaction from our render;\r\n            // all we need to do is to record that it's now mounted,\r\n            // to allow future observable changes to trigger re-renders\r\n            reactionTrackingRef.current.mounted = true;\r\n        }\r\n        else {\r\n            // The reaction we set up in our render has been disposed.\r\n            // This is either due to bad timings of renderings, e.g. our\r\n            // component was paused for a _very_ long time, and our\r\n            // reaction got cleaned up, or we got a observable change\r\n            // between render and useEffect\r\n            // Re-create the reaction\r\n            reactionTrackingRef.current = {\r\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n                    // We've definitely already been mounted at this point\r\n                    forceUpdate();\r\n                }),\r\n                cleanAt: Infinity\r\n            };\r\n            forceUpdate();\r\n        }\r\n        return () => {\r\n            reactionTrackingRef.current.reaction.dispose();\r\n            reactionTrackingRef.current = null;\r\n        };\r\n    }, []);\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    let rendering;\r\n    let exception;\r\n    reaction.track(() => {\r\n        try {\r\n            rendering = fn();\r\n        }\r\n        catch (e) {\r\n            exception = e;\r\n        }\r\n    });\r\n    if (exception) {\r\n        throw exception; // re-throw any exceptions catched during rendering\r\n    }\r\n    return rendering;\r\n}\r\n//# sourceMappingURL=useObserver.js.map","references":["D:/workspace/github/mobx-react-lite/node_modules/mobx/lib/mobx.d.ts","D:/workspace/github/mobx-react-lite/node_modules/@types/react/index.d.ts","D:/workspace/github/mobx-react-lite/src/printDebugValue.ts","D:/workspace/github/mobx-react-lite/src/reactionCleanupTracking.ts","D:/workspace/github/mobx-react-lite/src/staticRendering.ts","D:/workspace/github/mobx-react-lite/src/utils.ts"],"map":"{\"version\":3,\"file\":\"useObserver.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/useObserver.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/workspace/github/mobx-react-lite/useObserver.d.ts","writeByteOrderMark":false,"text":"export declare type ForceUpdateHook = () => () => void;\r\nexport interface IUseObserverOptions {\r\n    useForceUpdate?: ForceUpdateHook;\r\n}\r\nexport declare function useObserver<T>(fn: () => T, baseComponentName?: string, options?: IUseObserverOptions): T;\r\n"}}
