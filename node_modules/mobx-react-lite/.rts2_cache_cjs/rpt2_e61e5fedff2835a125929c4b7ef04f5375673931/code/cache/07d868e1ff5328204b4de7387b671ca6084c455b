{"code":"import { Reaction } from \"mobx\";\r\nimport React from \"react\";\r\nimport { printDebugValue } from \"./printDebugValue\";\r\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\r\nimport { isUsingStaticRendering } from \"./staticRendering\";\r\nimport { useForceUpdate } from \"./utils\";\r\nconst EMPTY_OBJECT = {};\r\nfunction observerComponentNameFor(baseComponentName) {\r\n    return `observer${baseComponentName}`;\r\n}\r\nexport function useObserver(fn, baseComponentName = \"observed\", options = EMPTY_OBJECT) {\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    const wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\r\n    const forceUpdate = wantedForceUpdateHook();\r\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\r\n    // rendered and abandoned multiple times, so we need to track leaked\r\n    // Reactions.\r\n    const reactionTrackingRef = React.useRef(null);\r\n    if (!reactionTrackingRef.current) {\r\n        // First render for this component (or first time since a previous\r\n        // reaction from an abandoned render was disposed).\r\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n            // Observable has changed, meaning we want to re-render\r\n            // BUT if we're a component that hasn't yet got to the useEffect()\r\n            // stage, we might be a component that _started_ to render, but\r\n            // got dropped, and we don't want to make state changes then.\r\n            // (It triggers warnings in StrictMode, for a start.)\r\n            if (trackingData.mounted) {\r\n                // We have reached useEffect(), so we're mounted, and can trigger an update\r\n                forceUpdate();\r\n            }\r\n            else {\r\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\r\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\r\n                // drop our current reaction and allow useEffect() to recreate it.\r\n                newReaction.dispose();\r\n                reactionTrackingRef.current = null;\r\n            }\r\n        });\r\n        const trackingData = createTrackingData(newReaction);\r\n        reactionTrackingRef.current = trackingData;\r\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\r\n    }\r\n    const { reaction } = reactionTrackingRef.current;\r\n    React.useDebugValue(reaction, printDebugValue);\r\n    React.useEffect(() => {\r\n        // Called on first mount only\r\n        recordReactionAsCommitted(reactionTrackingRef);\r\n        if (reactionTrackingRef.current) {\r\n            // Great. We've already got our reaction from our render;\r\n            // all we need to do is to record that it's now mounted,\r\n            // to allow future observable changes to trigger re-renders\r\n            reactionTrackingRef.current.mounted = true;\r\n        }\r\n        else {\r\n            // The reaction we set up in our render has been disposed.\r\n            // This is either due to bad timings of renderings, e.g. our\r\n            // component was paused for a _very_ long time, and our\r\n            // reaction got cleaned up, or we got a observable change\r\n            // between render and useEffect\r\n            // Re-create the reaction\r\n            reactionTrackingRef.current = {\r\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n                    // We've definitely already been mounted at this point\r\n                    forceUpdate();\r\n                }),\r\n                cleanAt: Infinity\r\n            };\r\n            forceUpdate();\r\n        }\r\n        return () => {\r\n            reactionTrackingRef.current.reaction.dispose();\r\n            reactionTrackingRef.current = null;\r\n        };\r\n    }, []);\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    let rendering;\r\n    let exception;\r\n    reaction.track(() => {\r\n        try {\r\n            rendering = fn();\r\n        }\r\n        catch (e) {\r\n            exception = e;\r\n        }\r\n    });\r\n    if (exception) {\r\n        throw exception; // re-throw any exceptions catched during rendering\r\n    }\r\n    return rendering;\r\n}\r\n","references":["D:/workspace/github/mobx-react-lite/node_modules/mobx/lib/mobx.d.ts","D:/workspace/github/mobx-react-lite/node_modules/@types/react/index.d.ts","D:/workspace/github/mobx-react-lite/src/printDebugValue.ts","D:/workspace/github/mobx-react-lite/src/reactionCleanupTracking.ts","D:/workspace/github/mobx-react-lite/src/staticRendering.ts","D:/workspace/github/mobx-react-lite/src/utils.ts"],"dts":{"name":"D:/workspace/github/mobx-react-lite/src/useObserver.d.ts","writeByteOrderMark":false,"text":"export declare type ForceUpdateHook = () => () => void;\r\nexport interface IUseObserverOptions {\r\n    useForceUpdate?: ForceUpdateHook;\r\n}\r\nexport declare function useObserver<T>(fn: () => T, baseComponentName?: string, options?: IUseObserverOptions): T;\r\n"}}
